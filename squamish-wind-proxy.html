<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Is it going to be windy in Squamish?</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Lexend:wght@100..900&display=swap" rel="stylesheet">
<link rel="stylesheet" href="styles.css">
  <script src="droids.js"></script>

</head>
<body>
<div class="wrap">
  <h1>Is it going to be windy in Squamish?</h1>
  <p>Based on the temperature difference between Vancouver and Lillooet BC</p>
  <div id="col" class="col"><!-- days injected here --></div>
</div>

<script>
(async function(){
  // ===== Config =====
  const HOURS = Array.from({length:13}, (_,i)=>8+i);         // 08..20 inclusive (show)
  const EVAL_START = 10, EVAL_END = 18;                      // daily % window (10â†’18)
  const MIN_DELTA = 0, MAX_DELTA = 9;                       // 0Â°C => 0%, 12Â°C => 100%

  // Per-hour divisors
  const HOUR_DIVISOR = {
    8: 3, 9: 2, 10: 1.5, 11: 1.2,
    12: 1, 13: 1, 14: 1, 15: 1, 16: 1, 17: 1, 18: 1,
    19: 1.2, 20: 1.3
  };

  const TZ = 'America/Vancouver';
  const VANCOUVER = { lat:49.2827, lon:-123.1207 };
  const SQUAMISH  = { lat:49.7016, lon:-123.1550 }; // for daily weather + air quality
  const LILLOOET  = { lat:50.6869, lon:-121.9420 };
  const HORIZON_DAYS = 8;

  const AQ_FORECAST_LIMIT_DAYS = 10; // Open-Meteo AQ forecast horizon

  // Atmospheric constants
  const ELEVATION_850MB = 1500;      // meters - 850mb pressure level elevation
  const STANDARD_LAPSE = 6.5;        // Â°C per 1000m - standard atmospheric lapse rate
  const INSTABILITY_MAX = 15;        // max +/- percentage points from instability
  const INSTABILITY_MULTIPLIER = 3;  // converts lapse rate deviation to points

  // Display constants
  const CLOUD_PENALTY_MAX = 20;      // max percentage points penalty for overcast
  const SMOKE_WARNING_THRESHOLD = 30; // PM2.5 Âµg/mÂ³ threshold for smoke warning
  const API_TIMEOUT_MS = 6000;       // timeout for API requests
  const MIN_SOURCE_COUNT_WARN = 2;   // warn if fewer than this many sources available
  

  const colEl = document.getElementById('col');

  // ===== Color helpers & constants =====
  function lerp(a,b,t){ return a + (b-a)*t; }
  function lerpColor(c1, c2, t){
    const r = Math.round(lerp(c1[0], c2[0], t));
    const g = Math.round(lerp(c1[1], c2[1], t));
    const b = Math.round(lerp(c1[2], c2[2], t));
    return `rgb(${r},${g},${b})`;
  }
  const C_WHITE     = [255,255,255];
  const C_YELLOW    = [255,234,123]; // (yellow)
  const C_GREEN_MAX = [ 34,197, 94]; // (green)

  // Color by adjusted Î”T (Â°C): 0â€“3 white, 3â€“5 whiteâ†’yellow, 5â€“8 yellowâ†’green, â‰¥8 green
  function cellBgForDelta(d){
    if (d == null || !isFinite(d)) return 'rgb(255,255,255)';
    if (d <= 3) return 'rgb(255,255,255)';
    if (d <= 5){
      const t = (d - 3) / 2;          // 0..1 across 3â†’5
      return lerpColor(C_WHITE, C_YELLOW, t);
    }
    if (d <= 8){
      const t = (d - 5) / 3;          // 0..1 across 5â†’8
      return lerpColor(C_YELLOW, C_GREEN_MAX, t);
    }
    return `rgb(${C_GREEN_MAX[0]},${C_GREEN_MAX[1]},${C_GREEN_MAX[2]})`;
  }



  // ===== Fetch & render =====
  try{
    // Fetch all data with individual error handling to allow partial failures
    const [van, lil, van850, lil850, squWx, squAQ, squCC] = await Promise.all([
      fetchHourlyAveraged(VANCOUVER.lat, VANCOUVER.lon, TZ, HORIZON_DAYS).catch(e => {
        console.error('Vancouver temp fetch failed:', e);
        return {};
      }),
      fetchHourlyAveraged(LILLOOET.lat,  LILLOOET.lon,  TZ, HORIZON_DAYS).catch(e => {
        console.error('Lillooet temp fetch failed:', e);
        return {};
      }),
      fetch850mbTemp(VANCOUVER.lat, VANCOUVER.lon, TZ, HORIZON_DAYS).catch(e => {
        console.warn('Vancouver 850mb fetch failed (instability will be neutral):', e);
        return {};
      }),
      fetch850mbTemp(LILLOOET.lat,  LILLOOET.lon,  TZ, HORIZON_DAYS).catch(e => {
        console.warn('Lillooet 850mb fetch failed (instability will be neutral):', e);
        return {};
      }),
      fetchSquamishDaily(TZ, HORIZON_DAYS).catch(e => {
        console.warn('Squamish weather icons fetch failed:', e);
        return {};
      }),
      fetchSquamishAQ(TZ, HORIZON_DAYS).catch(e => {
        console.warn('Air quality fetch failed:', e);
        return {};
      }),
      fetchSquamishCloudCover(TZ, HORIZON_DAYS).catch(e => {
        console.warn('Cloud cover fetch failed:', e);
        return {};
      })
    ]);

    // Check if we have minimum required data
    if (Object.keys(van).length === 0 && Object.keys(lil).length === 0) {
      throw new Error('Failed to fetch temperature data from all sources');
    }

    const perDay = buildDays(van, lil, van850, lil850, squWx, squAQ, squCC);

    if (perDay.length === 0) {
      throw new Error('No forecast data available');
    }

    render(perDay);
  } catch(e){
    console.error('Fatal error:', e);
    colEl.innerHTML = `<div style="color:#b91c1c;padding:20px;text-align:center;">
      <strong>Unable to load forecast</strong><br>
      ${e.message}<br>
      <small>Check console for details</small>
    </div>`;
  }

  /**
   * Build array of local timestamp strings for forecast period
   * @param {string} timezone - IANA timezone string
   * @param {number} days - Number of days to forecast
   * @returns {string[]} Array of 'YYYY-MM-DDTHH:00' timestamps
   */
  function requestedLocalStamps(timezone, days){
    const want = [];
    const start = new Date(); // now
    for(let d=0; d<days; d++){
      const day = addDays(start, d);
      const ymd = toYMD(day);
      for (let h=8; h<=20; h++){
        const s = `${ymd}T${String(h).padStart(2,'0')}:00`;
        want.push(s);
      }
    }
    return want; // array of 'YYYY-MM-DDTHH:00' in local tz
  }

  /**
   * Fetch and average hourly temperatures from multiple weather sources
   * @param {number} lat - Latitude
   * @param {number} lon - Longitude
   * @param {string} timezone - IANA timezone
   * @param {number} days - Forecast horizon
   * @returns {Promise<Object>} Map of timestamp -> averaged temperature in Â°C
   */
  async function fetchHourlyAveraged(lat, lon, timezone, days){
    const targets = requestedLocalStamps(timezone, days);
    // Kick all sources in parallel and fail-soft (empty maps if one fails)
    const [om, metno, owm] = await Promise.all([
      withTimeout(fetchOM(lat, lon, timezone, days).catch(()=> ({}))),
      withTimeout(fetchMetNo(lat, lon, timezone, days).catch(()=> ({}))),
      withTimeout(fetchOWM(lat, lon, timezone, days).catch(()=> ({}))),
    ]);
    // Average available temps per timestamp
    const out = {};
    for (const ts of targets){
      const vals = [om[ts], metno[ts], owm[ts]]
        .filter(v => typeof v === 'number' && isFinite(v));
      if (vals.length && vals.length < MIN_SOURCE_COUNT_WARN) {
        console.warn('Low source count for', ts, 'â†’ using', vals.length, 'provider(s)');
      }
      if (vals.length) out[ts] = vals.reduce((a,b)=>a+b,0) / vals.length;
    }
    return out;
  }
  function addDays(d, n){ const x=new Date(d); x.setDate(x.getDate()+n); return x; }
  function toYMD(d){
    return new Intl.DateTimeFormat('en-CA', { timeZone: TZ, year:'numeric', month:'2-digit', day:'2-digit' })
      .format(d).replaceAll('/','-');
  }

  /**
   * Convert temperature delta to wind probability percentage
   * @param {number|null} delta - Temperature difference in Â°C
   * @returns {number|null} Percentage (0-100) or null
   */
  function pctFromDelta(delta){
    if (delta==null || Number.isNaN(delta)) return null;
    if (delta <= MIN_DELTA) return 0;
    if (delta >= MAX_DELTA) return 100;
    return Math.round(((delta - MIN_DELTA) / (MAX_DELTA - MIN_DELTA)) * 100);
  }

  // Day badge color by daily average (computed on 11â†’18)
  function badgeClass(pct){
    if (pct==null) return 'gray';
    if (pct < 50)  return 'gray';
    if (pct < 65)  return 'yellow';
    if (pct < 80)  return 'orange';
    return 'red';
  }

  /**
   * Calculate atmospheric instability modifier based on lapse rate
   * @param {number|null} surfaceTemp - Surface temperature in Â°C
   * @param {number|null} temp850mb - Temperature at 850mb pressure level in Â°C
   * @returns {number} Modifier in percentage points (+/- INSTABILITY_MAX)
   *
   * Strong unstable atmosphere (steep lapse rate) = better thermal mixing = bonus
   * Stable atmosphere (weak lapse rate or inversion) = thermal suppression = penalty
   */
  function calcInstabilityModifier(surfaceTemp, temp850mb){
    if (surfaceTemp == null || temp850mb == null) return 0; // neutral if missing data

    const expectedDrop = (ELEVATION_850MB / 1000) * STANDARD_LAPSE; // ~9.75Â°C
    const actualDrop = surfaceTemp - temp850mb;
    const deviation = actualDrop - expectedDrop;

    // actualDrop > expectedDrop = steeper lapse = more unstable = good for thermals
    // actualDrop < expectedDrop = weaker lapse = more stable = bad for thermals
    const modifier = Math.max(-INSTABILITY_MAX, Math.min(INSTABILITY_MAX, deviation * INSTABILITY_MULTIPLIER));

    return modifier;
  }

  /**
   * Build daily forecast objects from all fetched weather data
   * @param {Object} van - Vancouver temperature map
   * @param {Object} lil - Lillooet temperature map
   * @param {Object} van850 - Vancouver 850mb temperature map
   * @param {Object} lil850 - Lillooet 850mb temperature map
   * @param {Object} squWx - Squamish WMO weather codes
   * @param {Object} squAQ - Squamish air quality (PM2.5)
   * @param {Object} squCC - Squamish cloud cover
   * @returns {Array} Array of day objects with cells and metrics
   */
  function buildDays(van, lil, van850, lil850, squWx, squAQ, squCC){
    const dates = new Set([...Object.keys(van), ...Object.keys(lil)].map(s=>s.slice(0,10)));
    const sorted = [...dates].sort();
    const today = toYMD(new Date());
    const nextN = sorted.filter(d=>d>=today).slice(0, HORIZON_DAYS);

    return nextN.map(dateStr=>{
      const cells = [];            // 13 hours
      const evalPcts = [];         // for 11..18 daily%
      const instabilities = [];    // for daily avg instability

      for (const h of HOURS){
        const ts = `${dateStr}T${String(h).padStart(2,'0')}:00`;
        const tv = van[ts], tl = lil[ts];
        const tv850 = van850?.[ts], tl850 = lil850?.[ts];
        const rawDelta = (typeof tv==='number' && typeof tl==='number') ? (tl - tv) : null; // Lillooet âˆ’ Vancouver

        // Calculate atmospheric instability at both locations and average
        const vanInstability = calcInstabilityModifier(tv, tv850);
        const lilInstability = calcInstabilityModifier(tl, tl850);
        const avgInstability = (vanInstability + lilInstability) / 2;

        // Apply hour-based divisor to the delta BEFORE mapping to %
        const divisor = HOUR_DIVISOR[h] ?? 1;
        const adjustedDelta = (rawDelta==null) ? null : (rawDelta / divisor);

        const pct = pctFromDelta(adjustedDelta);
        cells.push({ hour:h, pct, delta:rawDelta, adj:adjustedDelta, tv, tl, instability: avgInstability }); // add adjusted Î”T for coloring

        if (h>=EVAL_START && h<=EVAL_END && pct!=null) {
          evalPcts.push(pct);
          instabilities.push(avgInstability);
        }
      }
      const dayPct = evalPcts.length ? Math.round(evalPcts.reduce((a,b)=>a+b,0)/evalPcts.length) : null;
      const avgInstability = instabilities.length ? instabilities.reduce((a,b)=>a+b,0)/instabilities.length : 0;

      const wmo  = squWx?.[dateStr] ?? null;
      const pm25 = squAQ?.[dateStr] ?? null;
      const cloud = squCC?.[dateStr] ?? null; // average cloudcover% (11â€“18)
      return { dateStr, cells, dayPct, wmo, pm25, cloud, instability: avgInstability };
    });
  }

  /**
   * Build tooltip text for the daily percentage badge
   * @param {number} basePct - Base prediction percentage
   * @param {number} cloudPenalty - Cloud cover penalty
   * @param {number} instabilityBonus - Atmospheric instability modifier
   * @param {number} finalPct - Final calculated percentage
   * @returns {string} Formatted tooltip text
   */
  function buildBadgeTooltip(basePct, cloudPenalty, instabilityBonus, finalPct){
    const basePctStr = String(basePct).padStart(3);
    const cloudLineStr = (cloudPenalty > 0 ? `-${cloudPenalty}` : ` ${cloudPenalty}`).padStart(3);
    const stabilityLineStr = (instabilityBonus >= 0 ? `+${instabilityBonus}` : `${instabilityBonus}`).padStart(3);
    const finalPctStr = String(finalPct).padStart(3);

    return `Base prediction   ${basePctStr}%
Cloud cover       ${cloudLineStr} pts
Atmosphere        ${stabilityLineStr} pts
FINAL SCORE       ${finalPctStr}%`;
  }

  /**
   * Create the top section of a day card with label, weather icon, and percentage badge
   */
  function createDayCardTop(day, idx, todayStr, displayPct, cloudPenalty, instabilityBonus){
    const top = document.createElement('div');
    top.className = 'top';

    const dayLabel = (idx === 0) ? 'Today'
                    : (idx === 1) ? 'Tomorrow'
                    : formatDay(day.dateStr);
    const isToday = (day.dateStr === todayStr);
    const smokeWarn = (isToday && day.pm25 != null && day.pm25 >= SMOKE_WARNING_THRESHOLD);

    const badgeTooltip = day.dayPct == null ? '' :
      buildBadgeTooltip(day.dayPct, cloudPenalty, instabilityBonus, displayPct);

    top.innerHTML = `
      <div class="day">
          ${dayLabel}
          ${day.wmo!=null
             ? `<span class="wx" data-tip="Cloud cover avg: ${day.cloud!=null ? Math.round(day.cloud) : 'â€”'}%">${iconForWMO(day.wmo)}</span>`
             : ''}
          ${smokeWarn
            ? `<span class="smoke-warn" title="PM2.5 ~ ${day.pm25.toFixed(1)} Âµg/mÂ³">ðŸ”¥ fire smoke</span>`
            : ''}
       </div>
       <div class="badge ${badgeClass(displayPct)}" ${displayPct != null ? `data-tip="${badgeTooltip}"` : ''}>${displayPct==null ? 'â€”' : (displayPct + '%')}</div>
     `;

    return top;
  }

  /**
   * Create the hourly cells grid showing temperature deltas
   */
  function createHourlyCells(dayCells){
    const cells = document.createElement('div');
    cells.className = 'cells';

    dayCells.forEach(c=>{
      const div = document.createElement('div');
      const deltaTxt = (c.delta==null) ? 'â€”' : `${Math.round(c.delta)}Â°`;
      div.className = 'cell';
      div.style.background = cellBgForDelta(c.adj);

      const tip = `Vancouver: ${fmtTemp(c.tv)}
Lillooet: ${fmtTemp(c.tl)}`;
      div.setAttribute('data-tip', tip);
      div.innerHTML = `<small>${deltaTxt}</small>`;
      cells.appendChild(div);
    });

    return cells;
  }

  /**
   * Create the hour labels row
   */
  function createHourLabels(dayCells){
    const hrs = document.createElement('div');
    hrs.className = 'hours';
    dayCells.forEach(c=>{
      hrs.innerHTML += `<span>${hourLabel(c.hour)}</span>`;
    });
    return hrs;
  }

  /**
   * Render the forecast days into the DOM
   * @param {Array} days - Array of day objects from buildDays
   */
  function render(days){
    colEl.textContent = '';
    const frag = document.createDocumentFragment();
    const todayStr = toYMD(new Date());

    days.forEach((day, idx)=>{
      const card = document.createElement('div');
      card.className = 'card';

      const overcast = (day.cloud == null) ? 0 : Math.max(0, Math.min(100, day.cloud));
      const cloudPenalty = Math.round((overcast / 100) * CLOUD_PENALTY_MAX);
      const instabilityBonus = Math.round(day.instability ?? 0);
      const displayPct = (day.dayPct == null) ? null : Math.max(0, Math.min(100, day.dayPct - cloudPenalty + instabilityBonus));

      const top = createDayCardTop(day, idx, todayStr, displayPct, cloudPenalty, instabilityBonus);
      const cells = createHourlyCells(day.cells);
      const hrs = createHourLabels(day.cells);

      card.appendChild(top);
      card.appendChild(cells);
      card.appendChild(hrs);
      frag.appendChild(card);
    });

    colEl.appendChild(frag);
  }

  // ----- Utils -----
  function hourLabel(h){
    const suffix = h >= 12 ? 'PM' : 'AM';
    const hr12 = ((h + 11) % 12) + 1;
    return `${hr12} ${suffix}`;
  }
  function formatDay(ymd){
    const [y,m,d] = ymd.split('-').map(Number);
    return new Date(y, m-1, d).toLocaleDateString(undefined, { weekday:'long', month:'short', day:'numeric' });
  }
  function fmtTemp(x){ return (x==null) ? 'â€”' : `${x.toFixed(1)}Â°C`; }

  async function fetchSquamishDaily(timezone, days){
  const start_date = toYMD(new Date());
  const end_date   = toYMD(addDays(new Date(), Math.min(days, AQ_FORECAST_LIMIT_DAYS)));
  const url = new URL('https://api.open-meteo.com/v1/forecast');
  url.search = new URLSearchParams({
    latitude: SQUAMISH.lat,
    longitude: SQUAMISH.lon,
    daily: 'weathercode',
    timezone, start_date, end_date
  }).toString();
  const r = await fetch(url);
  if(!r.ok) throw new Error(`Open-Meteo daily ${r.status}`);
  const j = await r.json();
  const out = {};
  const t = j.daily.time, w = j.daily.weathercode;
  for(let i=0;i<t.length;i++) out[t[i]] = w[i];
  return out; // { 'YYYY-MM-DD': wmoCode }
}

async function fetchSquamishAQ(timezone, days){
  const base = 'https://air-quality-api.open-meteo.com/v1/air-quality';
  const common = {
    latitude: SQUAMISH.lat,
    longitude: SQUAMISH.lon,
    hourly: 'pm2_5',
    timezone
  };

  // Try forecast_days from 5 down to 1 until the API accepts it.
  for (const fd of [5,4,3,2,1]) {
    const url = new URL(base);
    url.search = new URLSearchParams({ ...common, forecast_days: Math.min(days, fd) }).toString();
    const r = await fetch(url);
    if (r.ok) {
      const j = await r.json();
      const out = {}; // date -> daily max pm2.5
      const t = j.hourly?.time || [];
      const v = j.hourly?.pm2_5 || [];
      for (let i=0;i<t.length;i++){
        const dateStr = t[i].slice(0,10);
        const val = v[i];
        if (typeof val === 'number'){
          out[dateStr] = Math.max(out[dateStr] ?? -Infinity, val);
        }
      }
      console.log('AQ pm2.5 daily max map:', out);
      return out;
    }
    if (r.status !== 400) {
      // Non-parameter error â†’ surface it
      throw new Error(`Open-Meteo AQ ${r.status}`);
    }
  }

  console.warn('Open-Meteo AQ: all forecast_days attempts failed; returning empty AQ data.');
  return {};
}


// WMO weather code to emoji icon
function iconForWMO(code){
  if (code==null) return 'Â·';
  const c = Number(code);
  if (c===0) return 'â˜€ï¸';
  if ([1,2].includes(c)) return 'ðŸŒ¤ï¸';
  if (c===3) return 'â˜ï¸';
  if ([45,48].includes(c)) return 'ðŸŒ«ï¸';
  if ([51,53,55,56,57,61,63,65,66,67,80,81,82].includes(c)) return 'ðŸŒ§ï¸';
  if ([71,73,75,77].includes(c)) return 'ðŸŒ¨ï¸';
  if ([95,96,99].includes(c)) return 'â›ˆï¸';
  return 'ðŸŒ¡ï¸';
}

async function fetchSquamishCloudCover(timezone, days){
  const start_date = toYMD(new Date());
  const end_date   = toYMD(addDays(new Date(), days));
  const url = new URL('https://api.open-meteo.com/v1/forecast');
  url.search = new URLSearchParams({
    latitude: SQUAMISH.lat,
    longitude: SQUAMISH.lon,
    hourly: 'cloudcover',   // 0..100 %
    timezone, start_date, end_date
  }).toString();

  const r = await fetch(url);
  if(!r.ok) throw new Error(`Open-Meteo cloudcover ${r.status}`);
  const j = await r.json();

  const out = {}; // date -> average cloudcover (11..18)
  const t = j.hourly?.time || [];
  const v = j.hourly?.cloudcover || [];
  const acc = {}; // date -> {sum, count}

  for (let i=0;i<t.length;i++){
    const dateStr = t[i].slice(0,10);
    const hour = Number(t[i].slice(11,13));
    if (hour >= EVAL_START && hour <= EVAL_END){
      const val = v[i];
      if (typeof val === 'number'){
        if (!acc[dateStr]) acc[dateStr] = { sum:0, count:0 };
        acc[dateStr].sum += val;
        acc[dateStr].count += 1;
      }
    }
  }
  for (const d in acc){
    out[d] = acc[d].count ? acc[d].sum / acc[d].count : null; // 0..100
  }
  return out;
}

// ---- Open-Meteo (hourly, native TZ) ----
async function fetchOM(lat, lon, timezone, days){
  const start_date = toYMD(new Date());
  const end_date   = toYMD(addDays(new Date(), days));
  const url = new URL('https://api.open-meteo.com/v1/forecast');
  url.search = new URLSearchParams({
    latitude: lat, longitude: lon,
    hourly: 'temperature_2m',
    timezone, start_date, end_date
  }).toString();
  const r = await fetch(url);
  if(!r.ok) throw new Error(`Open-Meteo ${r.status}`);
  const j = await r.json();
  const out = {};
  const t = j.hourly.time, v = j.hourly.temperature_2m;
  for(let i=0;i<t.length;i++) out[t[i]] = v[i];
  return out; // local 'YYYY-MM-DDTHH:00'
}

/**
 * Fetch 850mb (upper atmosphere) temperature data
 * @param {number} lat - Latitude
 * @param {number} lon - Longitude
 * @param {string} timezone - IANA timezone
 * @param {number} days - Forecast horizon
 * @returns {Promise<Object>} Map of timestamp -> temperature at 850mb in Â°C
 */
async function fetch850mbTemp(lat, lon, timezone, days){
  const start_date = toYMD(new Date());
  const end_date   = toYMD(addDays(new Date(), days));
  const url = new URL('https://api.open-meteo.com/v1/forecast');
  url.search = new URLSearchParams({
    latitude: lat, longitude: lon,
    hourly: 'temperature_850hPa', // 850mb level (~5000ft / 1500m)
    timezone, start_date, end_date
  }).toString();
  const r = await fetch(url);
  if(!r.ok) throw new Error(`Open-Meteo 850mb ${r.status}`);
  const j = await r.json();
  const out = {};
  const t = j.hourly.time, v = j.hourly.temperature_850hPa;
  for(let i=0;i<t.length;i++) out[t[i]] = v[i];
  return out; // local 'YYYY-MM-DDTHH:00' -> temp in Â°C
}

// ---- MET Norway (hourly UTC -> convert to local) ----
async function fetchMetNo(lat, lon, timezone, days){
  const until = addDays(new Date(), days);
  const url = new URL('https://api.met.no/weatherapi/locationforecast/2.0/compact');
  url.search = new URLSearchParams({ lat, lon }).toString();
  const r = await fetch(url, {
    headers: { 'User-Agent': 'squamish-wind-demo/1.0 hello@example.com' } // met.no requires identification
  });
  if(!r.ok) throw new Error(`met.no ${r.status}`);
  const j = await r.json();
  const out = {};
  const rows = j?.properties?.timeseries || [];
  for (const row of rows){
    const utcIso = row.time; // e.g., '2025-09-19T12:00:00Z'
    const d = new Date(utcIso);
    if (d > until) break;
    const temp = row?.data?.instant?.details?.air_temperature;
    if (typeof temp !== 'number') continue;
    const local = toLocalStamp(d, timezone); // 'YYYY-MM-DDTHH:00'
    out[local] = temp;
  }
  return out;
}

// ---- OpenWeatherMap (3h UTC -> interpolate to hourly, convert to local) ----
async function fetchOWM(lat, lon, timezone, days){
  const url = new URL('https://api.openweathermap.org/data/2.5/forecast');
  url.search = new URLSearchParams({
    lat, lon, appid: OWM, units: 'metric'
  }).toString();
  const r = await fetch(url);
  if(!r.ok) throw new Error(`OWM ${r.status}`);
  const j = await r.json();
  const list = j?.list || []; // 3-hourly
  // Build arrays in UTC
  const pts = list.map(x => ({ t: new Date(x.dt * 1000), v: x?.main?.temp })).filter(x => typeof x.v === 'number');
  // Interpolate to our local target stamps
  const targets = requestedLocalStamps(timezone, days);
  const out = {};
  for (const ts of targets){
    const dLocal = new Date(ts); // WARNING: this interprets as local system; we need exact local in TZ
    const d = fromLocalStampToUTC(ts, timezone); // Date in UTC matching that local stamp
    const v = interp(pts, d);
    if (v!=null) out[ts] = v;
  }
  return out;
  // Linear interpolation helper (UTC Date target)
  function interp(points, target){
    if (points.length === 0) return null;
    // find neighbors around target
    let prev = null, next = null;
    for (const p of points){
      if (p.t <= target) prev = p;
      if (p.t >= target){ next = p; break; }
    }
    if (!prev) return points[0].v;
    if (!next) return points[points.length-1].v;
    if (prev.t.getTime() === next.t.getTime()) return prev.v;
    const t = (target - prev.t) / (next.t - prev.t);
    return prev.v + (next.v - prev.v)*t;
  }
}


/**
 * Format a Date as 'YYYY-MM-DDTHH:00' in the given IANA timezone
 * @param {Date} d - Date object
 * @param {string} tz - IANA timezone string
 * @returns {string} Local timestamp string
 */
function toLocalStamp(d, tz){
  const fmt = new Intl.DateTimeFormat('en-CA', {
    timeZone: tz, year:'numeric', month:'2-digit', day:'2-digit',
    hour:'2-digit', minute:'2-digit', hour12:false
  });
  const parts = Object.fromEntries(fmt.formatToParts(d).map(p=>[p.type,p.value]));
  return `${parts.year}-${parts.month}-${parts.day}T${parts.hour}:00`;
}

/**
 * Convert local timestamp string in a timezone to UTC Date object
 * @param {string} localStamp - Local timestamp 'YYYY-MM-DDTHH:00'
 * @param {string} tz - IANA timezone string
 * @returns {Date} UTC Date object
 */
function fromLocalStampToUTC(localStamp, tz){
  // parse components
  const [ymd, hm] = localStamp.split('T');
  const [y,m,d] = ymd.split('-').map(Number);
  const [H] = hm.split(':').map(Number);
  // get the instant that has that local wall time in tz
  const dtf = new Intl.DateTimeFormat('en-US', {
    timeZone: tz, hour12:false, year:'numeric', month:'2-digit', day:'2-digit',
    hour:'2-digit', minute:'2-digit'
  });
  // Build a Date by binary searching the epoch that formats to the desired local
  // (simple & robust; runs only for a handful of targets)
  const target = `${String(m).padStart(2,'0')}/${String(d).padStart(2,'0')}/${y}, ${String(H).padStart(2,'0')}:00`;
  let lo = Date.UTC(y, m-1, d, H) - 36e5, hi = Date.UTC(y, m-1, d, H) + 36e5;
  for (let i=0;i<20;i++){
    const mid = new Date((lo+hi)/2);
    const parts = Object.fromEntries(dtf.formatToParts(mid).map(p=>[p.type,p.value]));
    const cur = `${parts.month}/${parts.day}/${parts.year}, ${parts.hour}:${parts.minute}`;
    if (cur < target) lo = mid.getTime(); else hi = mid.getTime();
  }
  return new Date(hi);
}

function withTimeout(promise, ms=API_TIMEOUT_MS){
  const t = new Promise((_, rej) => setTimeout(() => rej(new Error('timeout')), ms));
  return Promise.race([promise, t]);
}

// Mobile tooltip support - toggle on tap
document.addEventListener('click', function(e) {
  const target = e.target;

  // Check if clicking on an element with data-tip attribute
  if (target.hasAttribute('data-tip') || target.classList.contains('wx') || target.classList.contains('badge')) {
    // Find the actual tooltip element (might be the target or a parent)
    const tipEl = target.hasAttribute('data-tip') ? target :
                  target.closest('[data-tip]');

    if (tipEl && tipEl.hasAttribute('data-tip')) {
      // On mobile, toggle the show-tip class
      if (window.matchMedia('(hover: none)').matches) {
        e.preventDefault();

        // Close all other tooltips
        document.querySelectorAll('.show-tip').forEach(el => {
          if (el !== tipEl) el.classList.remove('show-tip');
        });

        // Toggle this tooltip
        tipEl.classList.toggle('show-tip');
      }
    }
  } else {
    // Clicked outside - close all tooltips
    document.querySelectorAll('.show-tip').forEach(el => {
      el.classList.remove('show-tip');
    });
  }
});

})();
</script>
</body>
</html>
