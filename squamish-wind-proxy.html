<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Squamish Strong Wind Likelihood</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Lexend:wght@100..900&display=swap" rel="stylesheet">
<link rel="stylesheet" href="styles.css">
</head>
<body>
<div class="wrap">
  <h1>Squamish Strong Wind Likelihood</h1>
  <p>Based on the temperature difference between Vancouver and Lillooet BC</p>
  <div id="col" class="col"><!-- days injected here --></div>
</div>

<script>
(async function(){
  // ===== Config =====
  const HOURS = Array.from({length:13}, (_,i)=>8+i);         // 08..20 inclusive (show)
  const EVAL_START = 11, EVAL_END = 18;                      // daily % window (11→18)
  const MIN_DELTA = 3, MAX_DELTA = 12;                       // 3°C => 0%, 12°C => 100%

  // Per-hour divisors
  const HOUR_DIVISOR = {
    8: 3, 9: 2, 10: 1.5, 11: 1.2,
    12: 1, 13: 1, 14: 1, 15: 1, 16: 1, 17: 1, 18: 1,
    19: 1.2, 20: 1.3
  };

  const TZ = 'America/Vancouver';
  const VANCOUVER = { lat:49.2827, lon:-123.1207 };
  const LILLOOET  = { lat:50.6869, lon:-121.9420 };
  const HORIZON_DAYS = 10;
  

  const colEl = document.getElementById('col');

  // ===== Color helpers & constants =====
  function lerp(a,b,t){ return a + (b-a)*t; }
  function lerpColor(c1, c2, t){
    const r = Math.round(lerp(c1[0], c2[0], t));
    const g = Math.round(lerp(c1[1], c2[1], t));
    const b = Math.round(lerp(c1[2], c2[2], t));
    return `rgb(${r},${g},${b})`;
  }
  const C_WHITE     = [255,255,255];
  const C_GREEN_MAX = [ 34,197, 94]; // max green at 80%

  // White until 40%; white→green ramp from 40→80; clamp at max green for 80–100
  function cellBgForPct(p){ // p in [0..100] or null
    if (p==null) return 'rgb(255,255,255)';
    const x = Math.max(0, Math.min(100, p));
    if (x <= 30) return 'rgb(255,255,255)';
    if (x <= 80){
      const t = (x-30)/(80-30);
      return lerpColor(C_WHITE, C_GREEN_MAX, t);
    }
    return `rgb(${C_GREEN_MAX[0]},${C_GREEN_MAX[1]},${C_GREEN_MAX[2]})`;
  }

  // ===== Fetch & render =====
  try{
    const [van, lil] = await Promise.all([
      fetchHourly(VANCOUVER.lat, VANCOUVER.lon, TZ, HORIZON_DAYS),
      fetchHourly(LILLOOET.lat,  LILLOOET.lon,  TZ, HORIZON_DAYS)
    ]);
    const perDay = buildDays(van, lil);
    render(perDay);
  } catch(e){
    console.error(e);
    colEl.innerHTML = `<div style="color:#b91c1c">Error: ${e.message}</div>`;
  }

  // ----- Fetch hourly temps -----
  async function fetchHourly(lat, lon, timezone, days){
    const today = new Date();
    const start_date = toYMD(today);
    const end_date = toYMD(addDays(today, days));
    const url = new URL('https://api.open-meteo.com/v1/forecast');
    url.search = new URLSearchParams({
      latitude:lat, longitude:lon,
      hourly:'temperature_2m',
      timezone, start_date, end_date
    }).toString();
    const r = await fetch(url);
    if(!r.ok) throw new Error(`Open-Meteo ${r.status}`);
    const j = await r.json();
    const out = {};
    const t = j.hourly.time, v = j.hourly.temperature_2m;
    for(let i=0;i<t.length;i++) out[t[i]] = v[i];
    return out;
  }
  function addDays(d, n){ const x=new Date(d); x.setDate(x.getDate()+n); return x; }
  function toYMD(d){
    return new Intl.DateTimeFormat('en-CA', { timeZone: TZ, year:'numeric', month:'2-digit', day:'2-digit' })
      .format(d).replaceAll('/','-');
  }

  // ----- Model: ΔT → % -----
  function pctFromDelta(delta){
    if (delta==null || Number.isNaN(delta)) return null;
    if (delta <= MIN_DELTA) return 0;
    if (delta >= MAX_DELTA) return 100;
    return Math.round(((delta - MIN_DELTA) / (MAX_DELTA - MIN_DELTA)) * 100);
  }

  // Day badge color by daily average (computed on 11→18)
  function badgeClass(pct){
    if (pct==null) return 'gray';
    if (pct < 50)  return 'gray';
    if (pct < 65)  return 'yellow';
    if (pct < 80)  return 'orange';
    return 'red';
  }

  // ----- Build per-day structures -----
  function buildDays(van, lil){
    const dates = new Set([...Object.keys(van), ...Object.keys(lil)].map(s=>s.slice(0,10)));
    const sorted = [...dates].sort();
    const today = toYMD(new Date());
    const nextN = sorted.filter(d=>d>=today).slice(0, HORIZON_DAYS);

    return nextN.map(dateStr=>{
      const cells = [];            // 13 hours
      const evalPcts = [];         // for 11..18 daily%
      for (const h of HOURS){
        const ts = `${dateStr}T${String(h).padStart(2,'0')}:00`;
        const tv = van[ts], tl = lil[ts];
        const rawDelta = (typeof tv==='number' && typeof tl==='number') ? (tl - tv) : null; // Lillooet − Vancouver

        // Apply hour-based divisor to the delta BEFORE mapping to %
        const divisor = HOUR_DIVISOR[h] ?? 1;
        const adjustedDelta = (rawDelta==null) ? null : (rawDelta / divisor);

        const pct = pctFromDelta(adjustedDelta);
        cells.push({ hour:h, pct, delta:rawDelta, tv, tl }); // keep raw temps + delta for tooltip

        if (h>=EVAL_START && h<=EVAL_END && pct!=null) evalPcts.push(pct);
      }
      const dayPct = evalPcts.length ? Math.round(evalPcts.reduce((a,b)=>a+b,0)/evalPcts.length) : null;
      return { dateStr, cells, dayPct };
    });
  }

  // ----- Render -----
  function render(days){
    colEl.textContent = '';
    const frag = document.createDocumentFragment();

    days.forEach((day, idx)=>{
      const card = document.createElement('div');
      card.className = 'card';

      const top = document.createElement('div');
      top.className = 'top';
      const dayLabel = (idx === 0) ? 'Today'
                      : (idx === 1) ? 'Tomorrow'
                      : formatDay(day.dateStr);
      top.innerHTML = `
        <div class="day">${dayLabel}</div>
        <div class="badge ${badgeClass(day.dayPct)}">${day.dayPct==null?'—':(day.dayPct+'%')}</div>
      `;

      const cells = document.createElement('div');
      cells.className = 'cells';
      day.cells.forEach(c=>{
        const div = document.createElement('div');
        const deltaTxt = (c.delta==null) ? '—' : `${Math.round(c.delta)}°`;
        div.className = 'cell';
        div.style.background = cellBgForPct(c.pct);
        // custom tooltip
        const tip = `Vancouver: ${fmtTemp(c.tv)}
Lillooet: ${fmtTemp(c.tl)}`;
        div.setAttribute('data-tip', tip);
        div.innerHTML = `<small>${deltaTxt}</small>`;
        cells.appendChild(div);
      });

      const hrs = document.createElement('div');
      hrs.className = 'hours';
      day.cells.forEach(c=>{
        hrs.innerHTML += `<span>${hourLabel(c.hour)}</span>`;
      });

      card.appendChild(top);
      card.appendChild(cells);
      card.appendChild(hrs);
      frag.appendChild(card);
    });

    colEl.appendChild(frag);
  }

  // ----- Utils -----
  function hourLabel(h){
    const suffix = h >= 12 ? 'PM' : 'AM';
    const hr12 = ((h + 11) % 12) + 1;
    return `${hr12} ${suffix}`;
  }
  function formatDay(ymd){
    const [y,m,d] = ymd.split('-').map(Number);
    return new Date(y, m-1, d).toLocaleDateString(undefined, { weekday:'long', month:'short', day:'numeric' });
  }
  function fmtTemp(x){ return (x==null) ? '—' : `${x.toFixed(1)}°C`; }

})();
</script>
</body>
</html>
