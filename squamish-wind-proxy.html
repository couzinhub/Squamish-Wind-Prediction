<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Is it going to be windy in Squamish?</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Lexend:wght@100..900&display=swap" rel="stylesheet">
<link rel="stylesheet" href="styles.css">
  <script src="droids.js"></script>

</head>
<body>
<div class="wrap">
  <h1>Is it going to be windy in Squamish?</h1>
  <p>Based on the temperature difference between Vancouver and Lillooet BC</p>
  <div id="col" class="col"><!-- days injected here --></div>
</div>

<script>
(async function(){
  // ===== Config =====
  const HOURS = Array.from({length:13}, (_,i)=>8+i);         // 08..20 inclusive (show)
  const EVAL_START = 10, EVAL_END = 18;                      // daily % window (10â†’18)
  const MIN_DELTA = 0, MAX_DELTA = 9;                       // 0Â°C => 0%, 12Â°C => 100%

  // Per-hour divisors
  const HOUR_DIVISOR = {
    8: 3, 9: 2, 10: 1.5, 11: 1.2,
    12: 1, 13: 1, 14: 1, 15: 1, 16: 1, 17: 1, 18: 1,
    19: 1.2, 20: 1.3
  };

  const TZ = 'America/Vancouver';
  const VANCOUVER = { lat:49.2827, lon:-123.1207 };
  const SQUAMISH  = { lat:49.7016, lon:-123.1550 }; // for daily weather + air quality
  const LILLOOET  = { lat:50.6869, lon:-121.9420 };
  const HORIZON_DAYS = 8;

  const AQ_FORECAST_LIMIT_DAYS = 10; // Open-Meteo AQ forecast horizon
  

  const colEl = document.getElementById('col');

  // ===== Color helpers & constants =====
  function lerp(a,b,t){ return a + (b-a)*t; }
  function lerpColor(c1, c2, t){
    const r = Math.round(lerp(c1[0], c2[0], t));
    const g = Math.round(lerp(c1[1], c2[1], t));
    const b = Math.round(lerp(c1[2], c2[2], t));
    return `rgb(${r},${g},${b})`;
  }
  const C_WHITE     = [255,255,255];
  const C_YELLOW    = [255,234,123]; // (yellow)
  const C_GREEN_MAX = [ 34,197, 94]; // (green)

  // Color by adjusted Î”T (Â°C): 0â€“3 white, 3â€“5 whiteâ†’yellow, 5â€“8 yellowâ†’green, â‰¥8 green
  function cellBgForDelta(d){
    if (d == null || !isFinite(d)) return 'rgb(255,255,255)';
    if (d <= 3) return 'rgb(255,255,255)';
    if (d <= 5){
      const t = (d - 3) / 2;          // 0..1 across 3â†’5
      return lerpColor(C_WHITE, C_YELLOW, t);
    }
    if (d <= 8){
      const t = (d - 5) / 3;          // 0..1 across 5â†’8
      return lerpColor(C_YELLOW, C_GREEN_MAX, t);
    }
    return `rgb(${C_GREEN_MAX[0]},${C_GREEN_MAX[1]},${C_GREEN_MAX[2]})`;
  }



  // ===== Fetch & render =====
  try{
    const [van, lil, squWx, squAQ, squCC] = await Promise.all([
      fetchHourlyAveraged(VANCOUVER.lat, VANCOUVER.lon, TZ, HORIZON_DAYS),
      fetchHourlyAveraged(LILLOOET.lat,  LILLOOET.lon,  TZ, HORIZON_DAYS),

    fetchSquamishDaily(TZ, HORIZON_DAYS),        // date -> WMO weather code
      fetchSquamishAQ(TZ, HORIZON_DAYS),            // date -> pm2.5 (Âµg/mÂ³) daytime max
      fetchSquamishCloudCover(TZ, HORIZON_DAYS)    // date -> avg cloudcover% (11â€“18)
    ]);
    const perDay = buildDays(van, lil, squWx, squAQ, squCC);
    render(perDay);
  } catch(e){
    console.error(e);
    colEl.innerHTML = `<div style="color:#b91c1c">Error: ${e.message}</div>`;
  }

  // ----- Fetch hourly temps -----
  // Build the exact local timestamps we care about: today..+days, 08..20 local
  function requestedLocalStamps(timezone, days){
    const want = [];
    const start = new Date(); // now
    for(let d=0; d<days; d++){
      const day = addDays(start, d);
      const ymd = toYMD(day);
      for (let h=8; h<=20; h++){
        const s = `${ymd}T${String(h).padStart(2,'0')}:00`;
        want.push(s);
      }
    }
    return want; // array of 'YYYY-MM-DDTHH:00' in local tz
  }

  async function fetchHourlyAveraged(lat, lon, timezone, days){
    const targets = requestedLocalStamps(timezone, days);
    // Kick all sources in parallel and fail-soft (empty maps if one fails)
    const [om, metno, owm] = await Promise.all([
      withTimeout(fetchOM(lat, lon, timezone, days).catch(()=> ({}))),
      withTimeout(fetchMetNo(lat, lon, timezone, days).catch(()=> ({}))),
      withTimeout(fetchOWM(lat, lon, timezone, days).catch(()=> ({}))),
    ]);
    // Average available temps per timestamp
    const out = {};
    for (const ts of targets){
      const vals = [om[ts], metno[ts], owm[ts]]
        .filter(v => typeof v === 'number' && isFinite(v));
      if (vals.length && vals.length < 2) {
        console.warn('Low source count for', ts, 'â†’ using', vals.length, 'provider(s)');
      }
      if (vals.length) out[ts] = vals.reduce((a,b)=>a+b,0) / vals.length;
    }
    return out;
  }
  function addDays(d, n){ const x=new Date(d); x.setDate(x.getDate()+n); return x; }
  function toYMD(d){
    return new Intl.DateTimeFormat('en-CA', { timeZone: TZ, year:'numeric', month:'2-digit', day:'2-digit' })
      .format(d).replaceAll('/','-');
  }

  // ----- Model: Î”T â†’ % -----
  function pctFromDelta(delta){
    if (delta==null || Number.isNaN(delta)) return null;
    if (delta <= MIN_DELTA) return 0;
    if (delta >= MAX_DELTA) return 100;
    return Math.round(((delta - MIN_DELTA) / (MAX_DELTA - MIN_DELTA)) * 100);
  }

  // Day badge color by daily average (computed on 11â†’18)
  function badgeClass(pct){
    if (pct==null) return 'gray';
    if (pct < 50)  return 'gray';
    if (pct < 65)  return 'yellow';
    if (pct < 80)  return 'orange';
    return 'red';
  }

  // ----- Build per-day structures -----
  function buildDays(van, lil, squWx, squAQ, squCC){
    const dates = new Set([...Object.keys(van), ...Object.keys(lil)].map(s=>s.slice(0,10)));
    const sorted = [...dates].sort();
    const today = toYMD(new Date());
    const nextN = sorted.filter(d=>d>=today).slice(0, HORIZON_DAYS);

    return nextN.map(dateStr=>{
      const cells = [];            // 13 hours
      const evalPcts = [];         // for 11..18 daily%
      for (const h of HOURS){
        const ts = `${dateStr}T${String(h).padStart(2,'0')}:00`;
        const tv = van[ts], tl = lil[ts];
        const rawDelta = (typeof tv==='number' && typeof tl==='number') ? (tl - tv) : null; // Lillooet âˆ’ Vancouver

        // Apply hour-based divisor to the delta BEFORE mapping to %
        const divisor = HOUR_DIVISOR[h] ?? 1;
        const adjustedDelta = (rawDelta==null) ? null : (rawDelta / divisor);

        const pct = pctFromDelta(adjustedDelta);
        cells.push({ hour:h, pct, delta:rawDelta, adj:adjustedDelta, tv, tl }); // add adjusted Î”T for coloring

        if (h>=EVAL_START && h<=EVAL_END && pct!=null) evalPcts.push(pct);
      }
      const dayPct = evalPcts.length ? Math.round(evalPcts.reduce((a,b)=>a+b,0)/evalPcts.length) : null;
      const wmo  = squWx?.[dateStr] ?? null;
      const pm25 = squAQ?.[dateStr] ?? null;
      const cloud = squCC?.[dateStr] ?? null; // average cloudcover% (11â€“18)
      const smokeRisk = (pm25==null) ? null : smokeRiskFromPM25(pm25); // %
      return { dateStr, cells, dayPct, wmo, pm25, smokeRisk, cloud };
    });
  }

  // ----- Render -----
  function render(days){
    colEl.textContent = '';
    const frag = document.createDocumentFragment();
    const todayStr = toYMD(new Date());

    days.forEach((day, idx)=>{
      const card = document.createElement('div');
      card.className = 'card';

      const top = document.createElement('div');
      top.className = 'top';
      const dayLabel = (idx === 0) ? 'Today'
                      : (idx === 1) ? 'Tomorrow'
                      : formatDay(day.dateStr);
      const isToday   = (day.dateStr === todayStr);
      const smokeWarn = (isToday && day.pm25 != null && day.pm25 >= 30); // visual only
      const overcast  = (day.cloud == null) ? 0 : Math.max(0, Math.min(100, day.cloud)); // 0..100
      const penalty   = Math.round((overcast / 100) * 20); // up to -20 points
      const displayPct = (day.dayPct == null) ? null : Math.max(0, day.dayPct - penalty);
      top.innerHTML = `
        <div class="day">
            ${dayLabel}
            ${day.wmo!=null
               ? `<span class="wx" data-tip="Cloud cover avg: ${day.cloud!=null ? Math.round(day.cloud) : 'â€”'}%">${iconForWMO(day.wmo)}</span>`
               : ''}
            ${smokeWarn
              ? `<span class="smoke-warn" title="PM2.5 ~ ${day.pm25.toFixed(1)} Âµg/mÂ³">ðŸ”¥ fire smoke</span>`
              : ''}
         </div>
         <div class="badge ${badgeClass(displayPct)}">${displayPct==null ? 'â€”' : (displayPct + '%')}</div>
       `;

      const cells = document.createElement('div');
      cells.className = 'cells';
      day.cells.forEach(c=>{
        const div = document.createElement('div');
        const deltaTxt = (c.delta==null) ? 'â€”' : `${Math.round(c.delta)}Â°`;
        div.className = 'cell';
        div.style.background = cellBgForDelta(c.adj);
        // custom tooltip
        const tip = `Vancouver: ${fmtTemp(c.tv)}
Lillooet: ${fmtTemp(c.tl)}`;
        div.setAttribute('data-tip', tip);
        div.innerHTML = `<small>${deltaTxt}</small>`;
        cells.appendChild(div);
      });

      const hrs = document.createElement('div');
      hrs.className = 'hours';
      day.cells.forEach(c=>{
        hrs.innerHTML += `<span>${hourLabel(c.hour)}</span>`;
      });

      card.appendChild(top);
      card.appendChild(cells);
      card.appendChild(hrs);
      frag.appendChild(card);
    });

    colEl.appendChild(frag);
  }

  // ----- Utils -----
  function hourLabel(h){
    const suffix = h >= 12 ? 'PM' : 'AM';
    const hr12 = ((h + 11) % 12) + 1;
    return `${hr12} ${suffix}`;
  }
  function formatDay(ymd){
    const [y,m,d] = ymd.split('-').map(Number);
    return new Date(y, m-1, d).toLocaleDateString(undefined, { weekday:'long', month:'short', day:'numeric' });
  }
  function fmtTemp(x){ return (x==null) ? 'â€”' : `${x.toFixed(1)}Â°C`; }

  async function fetchSquamishDaily(timezone, days){
  const start_date = toYMD(new Date());
  const end_date   = toYMD(addDays(new Date(), Math.min(days, AQ_FORECAST_LIMIT_DAYS)));
  const url = new URL('https://api.open-meteo.com/v1/forecast');
  url.search = new URLSearchParams({
    latitude: SQUAMISH.lat,
    longitude: SQUAMISH.lon,
    daily: 'weathercode',
    timezone, start_date, end_date
  }).toString();
  const r = await fetch(url);
  if(!r.ok) throw new Error(`Open-Meteo daily ${r.status}`);
  const j = await r.json();
  const out = {};
  const t = j.daily.time, w = j.daily.weathercode;
  for(let i=0;i<t.length;i++) out[t[i]] = w[i];
  return out; // { 'YYYY-MM-DD': wmoCode }
}

async function fetchSquamishAQ(timezone, days){
  const base = 'https://air-quality-api.open-meteo.com/v1/air-quality';
  const common = {
    latitude: SQUAMISH.lat,
    longitude: SQUAMISH.lon,
    hourly: 'pm2_5',
    timezone
  };

  // Try forecast_days from 5 down to 1 until the API accepts it.
  for (const fd of [5,4,3,2,1]) {
    const url = new URL(base);
    url.search = new URLSearchParams({ ...common, forecast_days: Math.min(days, fd) }).toString();
    const r = await fetch(url);
    if (r.ok) {
      const j = await r.json();
      const out = {}; // date -> daily max pm2.5
      const t = j.hourly?.time || [];
      const v = j.hourly?.pm2_5 || [];
      for (let i=0;i<t.length;i++){
        const dateStr = t[i].slice(0,10);
        const val = v[i];
        if (typeof val === 'number'){
          out[dateStr] = Math.max(out[dateStr] ?? -Infinity, val);
        }
      }
      console.log('AQ pm2.5 daily max map:', out);
      return out;
    }
    if (r.status !== 400) {
      // Non-parameter error â†’ surface it
      throw new Error(`Open-Meteo AQ ${r.status}`);
    }
  }

  console.warn('Open-Meteo AQ: all forecast_days attempts failed; returning empty AQ data.');
  return {};
}


function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function smokeRiskFromPM25(pm){ // simple linear 0â†’150 Âµg/mÂ³ â†’ 0â€“100%
  if (pm==null || !isFinite(pm)) return null;
  const p = clamp01(pm / 150);
  return Math.round(p * 100);
}

// WMO â†’ label + emoji (compact set)
function weatherNameForWMO(code){
  if (code==null) return 'â€”';
  const c = Number(code);
  if (c===0) return 'Clear';
  if ([1,2].includes(c)) return 'Partly cloudy';
  if (c===3) return 'Overcast';
  if ([45,48].includes(c)) return 'Fog';
  if ([51,53,55,56,57,61,63,65,66,67].includes(c)) return 'Rain';
  if ([71,73,75,77].includes(c)) return 'Snow';
  if ([80,81,82].includes(c)) return 'Showers';
  if ([95,96,99].includes(c)) return 'Thunderstorm';
  return 'Mixed';
}
function iconForWMO(code){
  if (code==null) return 'Â·';
  const c = Number(code);
  if (c===0) return 'â˜€ï¸';
  if ([1,2].includes(c)) return 'ðŸŒ¤ï¸';
  if (c===3) return 'â˜ï¸';
  if ([45,48].includes(c)) return 'ðŸŒ«ï¸';
  if ([51,53,55,56,57,61,63,65,66,67,80,81,82].includes(c)) return 'ðŸŒ§ï¸';
  if ([71,73,75,77].includes(c)) return 'ðŸŒ¨ï¸';
  if ([95,96,99].includes(c)) return 'â›ˆï¸';
  return 'ðŸŒ¡ï¸';
}

async function fetchSquamishCloudCover(timezone, days){
  const start_date = toYMD(new Date());
  const end_date   = toYMD(addDays(new Date(), days));
  const url = new URL('https://api.open-meteo.com/v1/forecast');
  url.search = new URLSearchParams({
    latitude: SQUAMISH.lat,
    longitude: SQUAMISH.lon,
    hourly: 'cloudcover',   // 0..100 %
    timezone, start_date, end_date
  }).toString();

  const r = await fetch(url);
  if(!r.ok) throw new Error(`Open-Meteo cloudcover ${r.status}`);
  const j = await r.json();

  const out = {}; // date -> average cloudcover (11..18)
  const t = j.hourly?.time || [];
  const v = j.hourly?.cloudcover || [];
  const acc = {}; // date -> {sum, count}

  for (let i=0;i<t.length;i++){
    const dateStr = t[i].slice(0,10);
    const hour = Number(t[i].slice(11,13));
    if (hour >= EVAL_START && hour <= EVAL_END){
      const val = v[i];
      if (typeof val === 'number'){
        if (!acc[dateStr]) acc[dateStr] = { sum:0, count:0 };
        acc[dateStr].sum += val;
        acc[dateStr].count += 1;
      }
    }
  }
  for (const d in acc){
    out[d] = acc[d].count ? acc[d].sum / acc[d].count : null; // 0..100
  }
  return out;
}

// ---- Open-Meteo (hourly, native TZ) ----
async function fetchOM(lat, lon, timezone, days){
  const start_date = toYMD(new Date());
  const end_date   = toYMD(addDays(new Date(), days));
  const url = new URL('https://api.open-meteo.com/v1/forecast');
  url.search = new URLSearchParams({
    latitude: lat, longitude: lon,
    hourly: 'temperature_2m',
    timezone, start_date, end_date
  }).toString();
  const r = await fetch(url);
  if(!r.ok) throw new Error(`Open-Meteo ${r.status}`);
  const j = await r.json();
  const out = {};
  const t = j.hourly.time, v = j.hourly.temperature_2m;
  for(let i=0;i<t.length;i++) out[t[i]] = v[i];
  return out; // local 'YYYY-MM-DDTHH:00'
}

// ---- MET Norway (hourly UTC -> convert to local) ----
async function fetchMetNo(lat, lon, timezone, days){
  const until = addDays(new Date(), days);
  const url = new URL('https://api.met.no/weatherapi/locationforecast/2.0/compact');
  url.search = new URLSearchParams({ lat, lon }).toString();
  const r = await fetch(url, {
    headers: { 'User-Agent': 'squamish-wind-demo/1.0 hello@example.com' } // met.no requires identification
  });
  if(!r.ok) throw new Error(`met.no ${r.status}`);
  const j = await r.json();
  const out = {};
  const rows = j?.properties?.timeseries || [];
  for (const row of rows){
    const utcIso = row.time; // e.g., '2025-09-19T12:00:00Z'
    const d = new Date(utcIso);
    if (d > until) break;
    const temp = row?.data?.instant?.details?.air_temperature;
    if (typeof temp !== 'number') continue;
    const local = toLocalStamp(d, timezone); // 'YYYY-MM-DDTHH:00'
    out[local] = temp;
  }
  return out;
}

// ---- OpenWeatherMap (3h UTC -> interpolate to hourly, convert to local) ----
async function fetchOWM(lat, lon, timezone, days){
  const url = new URL('https://api.openweathermap.org/data/2.5/forecast');
  url.search = new URLSearchParams({
    lat, lon, appid: OWM, units: 'metric'
  }).toString();
  const r = await fetch(url);
  if(!r.ok) throw new Error(`OWM ${r.status}`);
  const j = await r.json();
  const list = j?.list || []; // 3-hourly
  // Build arrays in UTC
  const pts = list.map(x => ({ t: new Date(x.dt * 1000), v: x?.main?.temp })).filter(x => typeof x.v === 'number');
  // Interpolate to our local target stamps
  const targets = requestedLocalStamps(timezone, days);
  const out = {};
  for (const ts of targets){
    const dLocal = new Date(ts); // WARNING: this interprets as local system; we need exact local in TZ
    const d = fromLocalStampToUTC(ts, timezone); // Date in UTC matching that local stamp
    const v = interp(pts, d);
    if (v!=null) out[ts] = v;
  }
  return out;
  // Linear interpolation helper (UTC Date target)
  function interp(points, target){
    if (points.length === 0) return null;
    // find neighbors around target
    let prev = null, next = null;
    for (const p of points){
      if (p.t <= target) prev = p;
      if (p.t >= target){ next = p; break; }
    }
    if (!prev) return points[0].v;
    if (!next) return points[points.length-1].v;
    if (prev.t.getTime() === next.t.getTime()) return prev.v;
    const t = (target - prev.t) / (next.t - prev.t);
    return prev.v + (next.v - prev.v)*t;
  }
}


// Format a Date 'd' as 'YYYY-MM-DDTHH:00' in the given IANA timezone
function toLocalStamp(d, tz){
  const fmt = new Intl.DateTimeFormat('en-CA', {
    timeZone: tz, year:'numeric', month:'2-digit', day:'2-digit',
    hour:'2-digit', minute:'2-digit', hour12:false
  });
  const parts = Object.fromEntries(fmt.formatToParts(d).map(p=>[p.type,p.value]));
  return `${parts.year}-${parts.month}-${parts.day}T${parts.hour}:00`;
}

// Given a local stamp 'YYYY-MM-DDTHH:00' in TZ, produce a UTC Date
function fromLocalStampToUTC(localStamp, tz){
  // parse components
  const [ymd, hm] = localStamp.split('T');
  const [y,m,d] = ymd.split('-').map(Number);
  const [H] = hm.split(':').map(Number);
  // get the instant that has that local wall time in tz
  const dtf = new Intl.DateTimeFormat('en-US', {
    timeZone: tz, hour12:false, year:'numeric', month:'2-digit', day:'2-digit',
    hour:'2-digit', minute:'2-digit'
  });
  // Build a Date by binary searching the epoch that formats to the desired local
  // (simple & robust; runs only for a handful of targets)
  const target = `${String(m).padStart(2,'0')}/${String(d).padStart(2,'0')}/${y}, ${String(H).padStart(2,'0')}:00`;
  let lo = Date.UTC(y, m-1, d, H) - 36e5, hi = Date.UTC(y, m-1, d, H) + 36e5;
  for (let i=0;i<20;i++){
    const mid = new Date((lo+hi)/2);
    const parts = Object.fromEntries(dtf.formatToParts(mid).map(p=>[p.type,p.value]));
    const cur = `${parts.month}/${parts.day}/${parts.year}, ${parts.hour}:${parts.minute}`;
    if (cur < target) lo = mid.getTime(); else hi = mid.getTime();
  }
  return new Date(hi);
}

// Convert a naive local string 'YYYY-MM-DDTHH:MM:SS' (assumed local to site) into our TZ stamp
function toTZStampFromNaive(localIso, tz){
  const [ymd, hms] = localIso.split('T');
  const [y,m,d] = ymd.split('-').map(Number);
  const [H,Min] = hms.split(':').map(Number);
  const dtf = new Intl.DateTimeFormat('en-CA', {
    timeZone: tz, year:'numeric', month:'2-digit', day:'2-digit',
    hour:'2-digit', minute:'2-digit', hour12:false
  });
  // find UTC instant that formats to this local time in tz
  const utc = fromLocalStampToUTC(`${ymd}T${String(H).padStart(2,'0')}:00`, tz);
  const parts = Object.fromEntries(dtf.formatToParts(utc).map(p=>[p.type,p.value]));
  return `${parts.year}-${parts.month}-${parts.day}T${parts.hour}:00`;
}

function withTimeout(promise, ms=6000){
  const t = new Promise((_, rej) => setTimeout(() => rej(new Error('timeout')), ms));
  return Promise.race([promise, t]);
}




})();
</script>
</body>
</html>
