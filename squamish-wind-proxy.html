<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Squamish Strong Wind Likelihood</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Lexend:wght@100..900&display=swap" rel="stylesheet">
<link rel="stylesheet" href="styles.css">
</head>
<body>
<div class="wrap">
  <h1>Squamish Strong Wind Likelihood</h1>
  <p>Based on the temperature difference between Vancouver and Lillooet BC</p>
  <div id="col" class="col"><!-- days injected here --></div>
</div>

<script>
(async function(){
  // ===== Config =====
  const HOURS = Array.from({length:13}, (_,i)=>8+i);         // 08..20 inclusive (show)
  const EVAL_START = 11, EVAL_END = 18;                      // daily % window (11â†’18)
  const MIN_DELTA = 3, MAX_DELTA = 12;                       // 3Â°C => 0%, 12Â°C => 100%

  // Per-hour divisors
  const HOUR_DIVISOR = {
    8: 3, 9: 2, 10: 1.5, 11: 1.2,
    12: 1, 13: 1, 14: 1, 15: 1, 16: 1, 17: 1, 18: 1,
    19: 1.2, 20: 1.3
  };

  const TZ = 'America/Vancouver';
  const VANCOUVER = { lat:49.2827, lon:-123.1207 };
  const SQUAMISH  = { lat:49.7016, lon:-123.1550 }; // for daily weather + air quality
  const LILLOOET  = { lat:50.6869, lon:-121.9420 };
  const HORIZON_DAYS = 10;
  const AQ_FORECAST_LIMIT_DAYS = 10; // Open-Meteo AQ forecast horizon
  

  const colEl = document.getElementById('col');

  // ===== Color helpers & constants =====
  function lerp(a,b,t){ return a + (b-a)*t; }
  function lerpColor(c1, c2, t){
    const r = Math.round(lerp(c1[0], c2[0], t));
    const g = Math.round(lerp(c1[1], c2[1], t));
    const b = Math.round(lerp(c1[2], c2[2], t));
    return `rgb(${r},${g},${b})`;
  }
  const C_WHITE     = [255,255,255];
  const C_YELLOW    = [255,234,123]; // (yellow)
  const C_GREEN_MAX = [ 34,197, 94]; // (green)

  // Color by adjusted Î”T (Â°C): 0â€“3 white, 3â€“7 whiteâ†’yellow, 7â€“10 yellowâ†’green, â‰¥10 green
  function cellBgForDelta(d){
    if (d==null || !isFinite(d)) return 'rgb(255,255,255)';
    if (d <= 4) return 'rgb(255,255,255)';
    if (d <= 8){
      const t = (d - 4) / 4;            // 0..1 across 3â†’7
      return lerpColor(C_WHITE, C_YELLOW, t);
    }
    if (d <= 12){
      const t = (d - 8) / 3;            // 0..1 across 7â†’10
      return lerpColor(C_YELLOW, C_GREEN_MAX, t);
    }
    return `rgb(${C_GREEN_MAX[0]},${C_GREEN_MAX[1]},${C_GREEN_MAX[2]})`;
  }

  // ===== Fetch & render =====
  try{
    const [van, lil, squWx, squAQ] = await Promise.all([
      fetchHourly(VANCOUVER.lat, VANCOUVER.lon, TZ, HORIZON_DAYS),
      fetchHourly(LILLOOET.lat,  LILLOOET.lon,  TZ, HORIZON_DAYS),
      fetchSquamishDaily(TZ, HORIZON_DAYS),        // date -> WMO weather code
      fetchSquamishAQ(TZ, HORIZON_DAYS)            // date -> pm2.5 (Âµg/mÂ³) daytime max
    ]);
    const perDay = buildDays(van, lil, squWx, squAQ);
    render(perDay);
  } catch(e){
    console.error(e);
    colEl.innerHTML = `<div style="color:#b91c1c">Error: ${e.message}</div>`;
  }

  // ----- Fetch hourly temps -----
  async function fetchHourly(lat, lon, timezone, days){
    const today = new Date();
    const start_date = toYMD(today);
    const end_date = toYMD(addDays(today, days));
    const url = new URL('https://api.open-meteo.com/v1/forecast');
    url.search = new URLSearchParams({
      latitude:lat, longitude:lon,
      hourly:'temperature_2m',
      timezone, start_date, end_date
    }).toString();
    const r = await fetch(url);
    if(!r.ok) throw new Error(`Open-Meteo ${r.status}`);
    const j = await r.json();
    const out = {};
    const t = j.hourly.time, v = j.hourly.temperature_2m;
    for(let i=0;i<t.length;i++) out[t[i]] = v[i];
    return out;
  }
  function addDays(d, n){ const x=new Date(d); x.setDate(x.getDate()+n); return x; }
  function toYMD(d){
    return new Intl.DateTimeFormat('en-CA', { timeZone: TZ, year:'numeric', month:'2-digit', day:'2-digit' })
      .format(d).replaceAll('/','-');
  }

  // ----- Model: Î”T â†’ % -----
  function pctFromDelta(delta){
    if (delta==null || Number.isNaN(delta)) return null;
    if (delta <= MIN_DELTA) return 0;
    if (delta >= MAX_DELTA) return 100;
    return Math.round(((delta - MIN_DELTA) / (MAX_DELTA - MIN_DELTA)) * 100);
  }

  // Day badge color by daily average (computed on 11â†’18)
  function badgeClass(pct){
    if (pct==null) return 'gray';
    if (pct < 50)  return 'gray';
    if (pct < 65)  return 'yellow';
    if (pct < 80)  return 'orange';
    return 'red';
  }

  // ----- Build per-day structures -----
  function buildDays(van, lil, squWx, squAQ){
    const dates = new Set([...Object.keys(van), ...Object.keys(lil)].map(s=>s.slice(0,10)));
    const sorted = [...dates].sort();
    const today = toYMD(new Date());
    const nextN = sorted.filter(d=>d>=today).slice(0, HORIZON_DAYS);

    return nextN.map(dateStr=>{
      const cells = [];            // 13 hours
      const evalPcts = [];         // for 11..18 daily%
      for (const h of HOURS){
        const ts = `${dateStr}T${String(h).padStart(2,'0')}:00`;
        const tv = van[ts], tl = lil[ts];
        const rawDelta = (typeof tv==='number' && typeof tl==='number') ? (tl - tv) : null; // Lillooet âˆ’ Vancouver

        // Apply hour-based divisor to the delta BEFORE mapping to %
        const divisor = HOUR_DIVISOR[h] ?? 1;
        const adjustedDelta = (rawDelta==null) ? null : (rawDelta / divisor);

        const pct = pctFromDelta(adjustedDelta);
        cells.push({ hour:h, pct, delta:rawDelta, adj:adjustedDelta, tv, tl }); // add adjusted Î”T for coloring

        if (h>=EVAL_START && h<=EVAL_END && pct!=null) evalPcts.push(pct);
      }
      const dayPct = evalPcts.length ? Math.round(evalPcts.reduce((a,b)=>a+b,0)/evalPcts.length) : null;
      const wmo  = squWx?.[dateStr] ?? null;
      const pm25 = squAQ?.[dateStr] ?? null;
      const smokeRisk = (pm25==null) ? null : smokeRiskFromPM25(pm25); // %
      return { dateStr, cells, dayPct, wmo, pm25, smokeRisk };
    });
  }

  // ----- Render -----
  function render(days){
    colEl.textContent = '';
    const frag = document.createDocumentFragment();
    const todayStr = toYMD(new Date());

    days.forEach((day, idx)=>{
      const card = document.createElement('div');
      card.className = 'card';

      const top = document.createElement('div');
      top.className = 'top';
      const dayLabel = (idx === 0) ? 'Today'
                      : (idx === 1) ? 'Tomorrow'
                      : formatDay(day.dateStr);
      const isToday   = (day.dateStr === todayStr);
      const smokeWarn = (isToday && day.pm25 != null && day.pm25 >= 30);
      const displayPct = (day.dayPct == null) ? null
                        : Math.max(0, Math.round(day.dayPct / (smokeWarn ? 3 : 1)));
      top.innerHTML = `
        <div class="day">
            ${dayLabel}
            ${day.wmo!=null ? `<span class="wx" title="${weatherNameForWMO(day.wmo)}">${iconForWMO(day.wmo)}</span>` : ''}
            ${smokeWarn
              ? `<span class="smoke-warn" title="PM2.5 ~ ${day.pm25.toFixed(1)} Âµg/mÂ³">ðŸ”¥ fire smoke</span>`
              : ''}
         </div>
         <div class="badge ${badgeClass(displayPct)}">${displayPct==null ? 'â€”' : (displayPct + '%')}</div>
       `;

      const cells = document.createElement('div');
      cells.className = 'cells';
      day.cells.forEach(c=>{
        const div = document.createElement('div');
        const deltaTxt = (c.delta==null) ? 'â€”' : `${Math.round(c.delta)}Â°`;
        div.className = 'cell';
        div.style.background = cellBgForDelta(c.adj);
        // custom tooltip
        const tip = `Vancouver: ${fmtTemp(c.tv)}
Lillooet: ${fmtTemp(c.tl)}`;
        div.setAttribute('data-tip', tip);
        div.innerHTML = `<small>${deltaTxt}</small>`;
        cells.appendChild(div);
      });

      const hrs = document.createElement('div');
      hrs.className = 'hours';
      day.cells.forEach(c=>{
        hrs.innerHTML += `<span>${hourLabel(c.hour)}</span>`;
      });

      card.appendChild(top);
      card.appendChild(cells);
      card.appendChild(hrs);
      frag.appendChild(card);
    });

    colEl.appendChild(frag);
  }

  // ----- Utils -----
  function hourLabel(h){
    const suffix = h >= 12 ? 'PM' : 'AM';
    const hr12 = ((h + 11) % 12) + 1;
    return `${hr12} ${suffix}`;
  }
  function formatDay(ymd){
    const [y,m,d] = ymd.split('-').map(Number);
    return new Date(y, m-1, d).toLocaleDateString(undefined, { weekday:'long', month:'short', day:'numeric' });
  }
  function fmtTemp(x){ return (x==null) ? 'â€”' : `${x.toFixed(1)}Â°C`; }

  async function fetchSquamishDaily(timezone, days){
  const start_date = toYMD(new Date());
  const end_date   = toYMD(addDays(new Date(), Math.min(days, AQ_FORECAST_LIMIT_DAYS)));
  const url = new URL('https://api.open-meteo.com/v1/forecast');
  url.search = new URLSearchParams({
    latitude: SQUAMISH.lat,
    longitude: SQUAMISH.lon,
    daily: 'weathercode',
    timezone, start_date, end_date
  }).toString();
  const r = await fetch(url);
  if(!r.ok) throw new Error(`Open-Meteo daily ${r.status}`);
  const j = await r.json();
  const out = {};
  const t = j.daily.time, w = j.daily.weathercode;
  for(let i=0;i<t.length;i++) out[t[i]] = w[i];
  return out; // { 'YYYY-MM-DD': wmoCode }
}

async function fetchSquamishAQ(timezone, days){
  const base = 'https://air-quality-api.open-meteo.com/v1/air-quality';
  const common = {
    latitude: SQUAMISH.lat,
    longitude: SQUAMISH.lon,
    hourly: 'pm2_5',
    timezone
  };

  // Try forecast_days from 5 down to 1 until the API accepts it.
  for (const fd of [5,4,3,2,1]) {
    const url = new URL(base);
    url.search = new URLSearchParams({ ...common, forecast_days: Math.min(days, fd) }).toString();
    const r = await fetch(url);
    if (r.ok) {
      const j = await r.json();
      const out = {}; // date -> daily max pm2.5
      const t = j.hourly?.time || [];
      const v = j.hourly?.pm2_5 || [];
      for (let i=0;i<t.length;i++){
        const dateStr = t[i].slice(0,10);
        const val = v[i];
        if (typeof val === 'number'){
          out[dateStr] = Math.max(out[dateStr] ?? -Infinity, val);
        }
      }
      console.log('AQ pm2.5 daily max map:', out);
      return out;
    }
    if (r.status !== 400) {
      // Non-parameter error â†’ surface it
      throw new Error(`Open-Meteo AQ ${r.status}`);
    }
  }

  console.warn('Open-Meteo AQ: all forecast_days attempts failed; returning empty AQ data.');
  return {};
}


function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function smokeRiskFromPM25(pm){ // simple linear 0â†’150 Âµg/mÂ³ â†’ 0â€“100%
  if (pm==null || !isFinite(pm)) return null;
  const p = clamp01(pm / 150);
  return Math.round(p * 100);
}

// WMO â†’ label + emoji (compact set)
function weatherNameForWMO(code){
  if (code==null) return 'â€”';
  const c = Number(code);
  if (c===0) return 'Clear';
  if ([1,2].includes(c)) return 'Partly cloudy';
  if (c===3) return 'Overcast';
  if ([45,48].includes(c)) return 'Fog';
  if ([51,53,55,56,57,61,63,65,66,67].includes(c)) return 'Rain';
  if ([71,73,75,77].includes(c)) return 'Snow';
  if ([80,81,82].includes(c)) return 'Showers';
  if ([95,96,99].includes(c)) return 'Thunderstorm';
  return 'Mixed';
}
function iconForWMO(code){
  if (code==null) return 'Â·';
  const c = Number(code);
  if (c===0) return 'â˜€ï¸';
  if ([1,2].includes(c)) return 'ðŸŒ¤ï¸';
  if (c===3) return 'â˜ï¸';
  if ([45,48].includes(c)) return 'ðŸŒ«ï¸';
  if ([51,53,55,56,57,61,63,65,66,67,80,81,82].includes(c)) return 'ðŸŒ§ï¸';
  if ([71,73,75,77].includes(c)) return 'ðŸŒ¨ï¸';
  if ([95,96,99].includes(c)) return 'â›ˆï¸';
  return 'ðŸŒ¡ï¸';
}


})();
</script>
</body>
</html>
